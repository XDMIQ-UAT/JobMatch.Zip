"""
Dependency Vulnerability Scanner.
Scans dependencies for known CVEs and security issues.
"""
import logging
import subprocess
import json
from typing import List, Dict, Any, Optional
from datetime import datetime

from security.risk_monitor import RiskMonitor, SecurityRisk, RiskLevel, RiskStatus

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Scans dependencies for vulnerabilities."""
    
    def __init__(self, risk_monitor: RiskMonitor):
        self.risk_monitor = risk_monitor
    
    def scan_requirements(self, requirements_path: str = "backend/requirements.txt") -> List[Dict[str, Any]]:
        """
        Scan requirements.txt for vulnerabilities.
        Uses safety-db or similar tools.
        """
        vulnerabilities = []
        
        try:
            # Try using safety (if installed)
            result = subprocess.run(
                ["safety", "check", "--json", "--file", requirements_path],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                # No vulnerabilities found
                logger.info("No vulnerabilities found in dependencies")
                return []
            
            # Parse safety output
            try:
                safety_data = json.loads(result.stdout)
                for vuln in safety_data.get("vulnerabilities", []):
                    vulnerabilities.append({
                        "package": vuln.get("package"),
                        "installed_version": vuln.get("installed_version"),
                        "vulnerability_id": vuln.get("vulnerability_id"),
                        "vulnerability": vuln.get("vulnerability"),
                        "severity": self._parse_severity(vuln.get("severity", "unknown")),
                        "advisory": vuln.get("advisory", "")
                    })
            except json.JSONDecodeError:
                logger.warning("Could not parse safety output")
        
        except FileNotFoundError:
            logger.warning("safety tool not installed. Install with: pip install safety")
            # Fallback: Check for known issues manually
            vulnerabilities.extend(self._manual_checks(requirements_path))
        
        except subprocess.TimeoutExpired:
            logger.error("Vulnerability scan timed out")
        
        # Register vulnerabilities as risks
        for vuln in vulnerabilities:
            self._register_vulnerability_risk(vuln)
        
        return vulnerabilities
    
    def _parse_severity(self, severity: str) -> str:
        """Parse severity string to standard format."""
        severity_lower = severity.lower()
        if "critical" in severity_lower or "high" in severity_lower:
            return "high"
        elif "medium" in severity_lower:
            return "medium"
        else:
            return "low"
    
    def _manual_checks(self, requirements_path: str) -> List[Dict[str, Any]]:
        """Manual checks for known issues."""
        vulnerabilities = []
        
        # Check for duplicate dependencies
        with open(requirements_path, 'r') as f:
            lines = f.readlines()
            packages = {}
            for i, line in enumerate(lines, 1):
                line = line.strip()
                if '==' in line:
                    package = line.split('==')[0].strip()
                    if package in packages:
                        vulnerabilities.append({
                            "package": package,
                            "issue": "duplicate_entry",
                            "severity": "low",
                            "locations": [packages[package], i]
                        })
                    else:
                        packages[package] = i
        
        return vulnerabilities
    
    def _register_vulnerability_risk(self, vulnerability: Dict[str, Any]):
        """Register vulnerability as a security risk."""
        package = vulnerability.get("package", "unknown")
        severity = vulnerability.get("severity", "medium")
        
        risk_level = RiskLevel.MEDIUM
        if severity == "high" or severity == "critical":
            risk_level = RiskLevel.HIGH
        
        risk = SecurityRisk(
            risk_id=f"VULN-{package.upper().replace('-', '_')}",
            title=f"Vulnerability in {package}",
            description=vulnerability.get("vulnerability", "Unknown vulnerability"),
            level=risk_level,
            category="Dependency Vulnerability",
            location=f"backend/requirements.txt ({package})",
            remediation_steps=[
                f"Update {package} to patched version",
                "Review vulnerability advisory",
                "Test updated package",
                "Deploy fix"
            ]
        )
        
        self.risk_monitor.register_risk(risk)
    
    def scan_python_code(self, code_path: str = "backend") -> List[Dict[str, Any]]:
        """Scan Python code for security issues using bandit."""
        issues = []
        
        try:
            result = subprocess.run(
                ["bandit", "-r", code_path, "-f", "json"],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                try:
                    bandit_data = json.loads(result.stdout)
                    for issue in bandit_data.get("results", []):
                        issues.append({
                            "file": issue.get("filename"),
                            "line": issue.get("line_number"),
                            "severity": issue.get("issue_severity"),
                            "confidence": issue.get("issue_confidence"),
                            "test_id": issue.get("test_id"),
                            "issue": issue.get("issue_text")
                        })
                except json.JSONDecodeError:
                    logger.warning("Could not parse bandit output")
        
        except FileNotFoundError:
            logger.warning("bandit tool not installed. Install with: pip install bandit")
        
        except subprocess.TimeoutExpired:
            logger.error("Code scan timed out")
        
        return issues


def create_vulnerability_scanner(risk_monitor: RiskMonitor) -> VulnerabilityScanner:
    """Factory function to create vulnerability scanner."""
    return VulnerabilityScanner(risk_monitor)

